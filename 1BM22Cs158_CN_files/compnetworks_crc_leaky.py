# -*- coding: utf-8 -*-
"""Compnetworks.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KJH2NL3M1RDz977C8ak2Jqg9bzO2X1ND

#CRC
"""

def xor(a, b):
    # Perform XOR between two binary strings
    result = []
    for i in range(1, len(b)):
        if a[i] == b[i]:
            result.append('0')
        else:
            result.append('1')
    return ''.join(result)

def mod2div(dividend, divisor):
    # Perform modulo-2 division and return the remainder
    pick = len(divisor)
    tmp = dividend[0:pick]

    while pick < len(dividend):
        if tmp[0] == '1':
            tmp = xor(divisor, tmp) + dividend[pick]
        else:
            tmp = xor('0'*pick, tmp) + dividend[pick]
        pick += 1

    if tmp[0] == '1':
        tmp = xor(divisor, tmp)
    else:
        tmp = xor('0'*pick, tmp)

    return tmp

def encodeData(data, key):
    # Append zeros to the data
    l_key = len(key)
    appended_data = data + '0'*(l_key-1)
    remainder = mod2div(appended_data, key)
    codeword = data + remainder
    return codeword

# Example usage
data = '11010011101100'
key = '1011'
codeword = encodeData(data, key)
print("Encoded Data (Data + CRC):", codeword)

"""#detailed code"""

def xor(a, b):
    # Perform XOR between two binary strings
    result = []
    for i in range(1, len(b)):
        if a[i] == b[i]:
            result.append('0')
        else:
            result.append('1')
    return ''.join(result)

def mod2div(dividend, divisor):
    # Perform modulo-2 division and return the remainder
    print(f"\nStarting Modulo-2 Division")
    print(f"Dividend: {dividend}")
    print(f"Divisor:  {divisor}")
    pick = len(divisor)
    tmp = dividend[0:pick]
    print(f"Initial Segment: {tmp}")

    while pick < len(dividend):
        if tmp[0] == '1':
            print(f"Step: XOR with divisor ({divisor})")
            tmp = xor(divisor, tmp) + dividend[pick]
        else:
            print(f"Step: XOR with zeros ({'0'*pick})")
            tmp = xor('0'*pick, tmp) + dividend[pick]
        print(f"Intermediate Result: {tmp}")
        pick += 1

    if tmp[0] == '1':
        tmp = xor(divisor, tmp)
    else:
        tmp = xor('0'*pick, tmp)

    print(f"Final Remainder: {tmp}")
    return tmp

def encodeData(data, key):
    # Append zeros to the data
    l_key = len(key)
    appended_data = data + '0'*(l_key-1)
    print(f"\nSender Side:")
    print(f"Original Data: {data}")
    print(f"Appended Data: {appended_data}")
    remainder = mod2div(appended_data, key)
    codeword = data + remainder
    print(f"Encoded Data (Data + CRC): {codeword}")
    return codeword

def verifyData(codeword, key):
    print(f"\nReceiver Side:")
    print(f"Received Codeword: {codeword}")
    remainder = mod2div(codeword, key)
    if int(remainder) == 0:
        print("No error detected in the received data!")
    else:
        print("Error detected in the received data!")

# Example usage
data = '11010011101100'
key = '1011'

# Sender Side
codeword = encodeData(data, key)

# Receiver Side (Simulating a correct transmission)
verifyData(codeword, key)

# Receiver Side (Simulating an error in transmission)
print("\nSimulating transmission error...")
erroneous_codeword = codeword[:10] + '1' + codeword[11:]  # Introduce an error
verifyData(erroneous_codeword, key)

def xor(a, b):
    # Perform XOR between two binary strings
    result = []
    for i in range(1, len(b)):
        if a[i] == b[i]:
            result.append('0')
        else:
            result.append('1')
    return ''.join(result)

def mod2div(dividend, divisor):
    # Perform modulo-2 division and return the remainder
    pick = len(divisor)
    tmp = dividend[0:pick]

    while pick < len(dividend):
        if tmp[0] == '1':
            tmp = xor(divisor, tmp) + dividend[pick]
        else:
            tmp = xor('0'*pick, tmp) + dividend[pick]
        pick += 1

    if tmp[0] == '1':
        tmp = xor(divisor, tmp)
    else:
        tmp = xor('0'*pick, tmp)

    return tmp

def encodeData(data, key):
    # Append zeros to the data
    l_key = len(key)
    appended_data = data + '0'*(l_key-1)
    remainder = mod2div(appended_data, key)
    codeword = data + remainder
    return codeword

def verifyData(codeword, key):
    remainder = mod2div(codeword, key)
    if int(remainder) == 0:
        return "No error detected in the received data!"
    else:
        return "Error detected in the received data!"

# Example usage
data = '11010011101100'
key = '1011'

# Sender Side
codeword = encodeData(data, key)

# Receiver Side (Simulating a correct transmission)
result_correct = verifyData(codeword, key)

# Receiver Side (Simulating an error in transmission)
erroneous_codeword = codeword[:10] + '1' + codeword[11:]  # Introduce an error
result_error = verifyData(erroneous_codeword, key)

# Outputs
print("Original Data:", data)
print("Generator Polynomial:", key)
print("Encoded Data (Codeword):", codeword)
print("\nReceiver Verification (Correct Transmission):", result_correct)
print("Receiver Verification (Erroneous Transmission):", result_error)

"""leaky buckets"""

import time

class LeakyBucket:
    def __init__(self, capacity, leak_rate):
        self.capacity = capacity  # Maximum capacity of the bucket
        self.leak_rate = leak_rate  # Rate at which the bucket leaks (packets per second)
        self.current_level = 0  # Current fill level of the bucket
        self.last_check = time.time()  # Last time the bucket was checked

    def _leak(self):
        now = time.time()
        elapsed = now - self.last_check
        # Calculate how much the bucket has leaked since the last check
        leaked_amount = elapsed * self.leak_rate
        # Decrease the current level by the leaked amount
        self.current_level = max(0, self.current_level - leaked_amount)
        self.last_check = now

    def add_packet(self, packet_size):
        self._leak()
        if self.current_level + packet_size <= self.capacity:
            # There's enough space in the bucket; add the packet
            self.current_level += packet_size
            print(f"Packet of size {packet_size} added. Current bucket level: {self.current_level:.2f}")
            return True
        else:
            # Not enough space; packet is discarded
            print(f"Packet of size {packet_size} discarded. Bucket overflow.")
            return False

# Example usage
bucket = LeakyBucket(capacity=10, leak_rate=1)  # Capacity of 10 units, leaks 1 unit per second

# Simulate incoming packets
packet_sizes = [2, 3, 5, 2, 6]
for size in packet_sizes:
    bucket.add_packet(size)
    time.sleep(1)  # Wait for 1 second between packet arrivals